[id='chap-kogito-using-drl-rules']
= Using DRL rules in {PRODUCT} services
:context: drl-rules
:assembly: false

As a developer of business decisions, you can define business rules using Drools Rule Language (DRL) directly in free-form `.drl` text files. A DRL file can contain one or more rules that define at a minimum the rule conditions (`when`) and actions (`then`).

[id='con-drl_{context}']
== Drools Rule Language (DRL)

Drools Rule Language (DRL) is a notation established by the https://www.drools.org/[Drools] open source business automation project for defining and describing business rules. You define DRL rules in `.drl` text files. A DRL file can contain one or more rules that define at a minimum the rule conditions (`when`) and actions (`then`).

DRL files consist of the following components:

.Components in a DRL file
[source,subs="attributes+"]
----
package
unit

import

declare   // Optional

query  // Optional

rule "rule name"
    // Attributes
    when
        // Conditions
    then
        // Actions
end

rule "rule2 name"

...

----

The following example DRL rule determines the age limit in a loan application decision service:

.Example rule for loan application age limit
[source]
----
rule "Underage"
  when
    /applicant[ applicantName : name, age < 21 ]
    $application : /loanApplication[ applicant == applicantName ]
  then
    $application.setApproved( false );
    $application.setExplanation( "Underage" );
end
----

A DRL file can contain single or multiple rules and queries, and can define resource declarations and attributes that are assigned and used by your rules and queries. The components in a DRL file are grouped in a defined rule unit that serves as a unique namespace for each group of rules. The DRL package followed by the rule unit definition must be listed at the top of a DRL file, and the rules are typically listed last. All other DRL components can follow any order.

Each rule must have a unique name within the rule unit. If you use the same rule name more than once in any DRL file in the unit, the rules fail to compile. Rule names generally must follow standard Java identifier conventions. However, you can enclose rule names with double quotation marks (`rule "rule name"`) to  prevent possible compilation errors, especially if you use spaces in rule names.

[id='con-drl-packages_{context}']
== Packages in DRL

A package is a folder of related assets in {PRODUCT}, such as data objects, DRL files, decision tables, and other asset types. A package also serves as a unique namespace for each group of rules. A single rule base can contain multiple packages. You typically store all the rules for a package in the same file as the package declaration so that the package is self-contained. However, you can import objects from other packages that you want to use in the rules.

The following example is a package name and namespace for a DRL file in a mortgage application decision service:

.Example package definition in a DRL file
[source]
----
package org.mortgages;
----

ifdef::KOGITO-COMM[]
The following railroad diagram shows all the components that may make up a package:

.Package
image::kogito/drl/package.png[align="center"]

Note that a package _must_ have a namespace and be declared using standard Java conventions for package names; i.e., no spaces, unlike rule names which allow spaces.
In terms of the order of elements, they can appear in any order in the rule file, with the exception of the `package` and `unit` statements, which must be at the top of the file.
In all cases, the semicolons are optional.

Notice that any rule attribute (as described in the section xref:rules-attributes-ref-drl-rules[]) may also be written at package level, superseding the attribute's default value.
The modified default may still be replaced by an attribute setting within a rule.
endif::[]

[id='con-drl-imports_{context}']
== Import statements in DRL

ifdef::KOGITO-COMM[]
.Import
image::kogito/drl/import.png[align="center"]
endif::[]

Similar to import statements in Java, imports in DRL files identify the fully qualified paths and type names for any objects that you want to use in the rules. You specify the package and data object in the format `packageName.objectName`, with multiple imports on separate lines. The {DECISION_ENGINE} automatically imports classes from the Java package with the same name as the DRL package and from the package `java.lang`.

The following example is an import statement for a loan application object in a mortgage application decision service:

.Example import statement in a DRL file
[source]
----
import org.mortgages.LoanApplication;
----

[id='con-drl-rule-units_{context}']
== Rule units in DRL

A DRL rule unit is a module for rules and a unit of execution. A rule unit collects a set of rules with the declaration of the type of facts that the rules act on. A rule unit also serves as a unique namespace for each group of rules. A single rule base can contain multiple rule units. You typically store all the rules for a unit in the same file as the unit declaration so that the unit is self-contained.

The following example is a rule unit designated in a DRL file in a mortgage application decision service:

.Example package definition and rule unit designation in a DRL file
[source]
----
package org.mortgages;
unit MortgageRules;
----

To define a rule unit, you declare the relevant fact types and declare the data sources for the types by implementing the `RuleUnitData` interface, and then define the rules in the unit:

.Example DRL rule unit file
[source]
----
package org.mortgages;
unit MortgageRules;

import org.kie.kogito.rules.DataSource;
import org.kie.kogito.rules.DataStream;

declare Person
    name : String
    dateOfBirth : Date
    address : Address
end

declare MortgageRules extends RuleUnitData
  person: DataStream<Person> = DataSource.createStream()
end

rule "Using a rule unit with a declared type"
  when
    $p : /person[ name == "James" ]
  then   // Insert Mark, who is a customer of James.
    Person mark = new Person();
    mark.setName( "Mark" );
    person.append( mark );
end
----

To separate the fact types from the rule unit for use with other DRL rules, you can declare the types in a separate DRL file and then use the DRL rule file to declare the data sources by using the `RuleUnitData` interface implementation:

.Example DRL type declaration as a separate file
[source]
----
package org.mortgages;

declare Person
    name : String
    dateOfBirth : Date
    address : Address
end
----

.Example DRL rule unit file without explicitly defined types
[source]
----
package org.mortgages;
unit MortgageRules;

import org.kie.kogito.rules.DataSource;
import org.kie.kogito.rules.DataStream;

declare MortgageRules extends RuleUnitData
  person: DataStream<Person> = DataSource.createStream()
end

rule "Using a rule unit with a declared type"
  when
    $p : /person[ name == "James" ]
  then   // Insert Mark, who is a customer of James.
    Person mark = new Person();
    mark.setName( "Mark" );
    person.append( mark );
end
----

In this example, `persons` is a `DataStream` data source for facts of type `Person`. Data sources are typed sources of data that rule units can subscribe to for updates. You interact with the rule unit through the data sources it exposes. A data source can be a `DataStream` source for append-only storage, a `DataStore` source for writable storage to add or remove data, or a `SingletonStore` source for writable storage to set and clear a single element.

As part of your data source declaration, you also import `org.kie.kogito.rules.DataSource` and the relevant data source support, such as `import org.kie.kogito.rules.DataStream` in this example.

You can add several rules to the same DRL file, or further break down the rule set and type declarations by creating more files. However you construct your rule sets, ensure that all DRL rule files exist in the same directory and start with the correct `package` and `unit` declarations.

=== Rule unit use case

As an additional rule unit use case, consider the following example decision service that evaluates incoming data from a heat sensor for temperature measurements and produces alerts when the temperature is above a specified threshold.

This example service uses the following `types.drl` file in the `src/main/resources/org/acme` folder of the {PRODUCT} project to declare the `Temperature` and the `Alert` fact types:

.Example DRL type declarations
[source]
----
package com.acme;

declare Temperature
  value: double
end

declare Alert
    severity: String
    message: String
end
----

To define DRL rules that pattern-match against `Temperature` values, the example service must expose an entry point for the incoming data to the {DECISION_ENGINE} and publish alerts on a separate channel. To establish this data source for decision data, the example service uses a rule unit with `DataStream` data sources for `Temperature` objects and for `Alert` objects.

The `DataStream` data source is an append-only store for incoming data, similar to a queue. This type of data source is logical for both sources in this example because the temperature data is coming from an external source (the sensor) and the service publishes the alerts externally as they are produced.

The example service uses the following `MonitoringService.drl` file in the same `src/main/resources/com/acme` folder of the {PRODUCT} project to declare the data sources for the fact types and defines the rules for the rule unit:

.Example DRL rule unit file
[source]
----
package com.acme;
unit MonitoringService;

import org.kie.kogito.rules.DataSource;
import org.kie.kogito.rules.DataStream;

declare MonitoringService extends RuleUnitData
  temperature: DataStream<Temperature> = DataSource.createStream()
  alertData: DataStream<Alert> = DataSource.createStream()
end

rule "tooHot"
when
    $temp : /temperature[value >= 80]
then
    alertData.append(new Alert("HIGH", "Temperature exceeds threshold: " + temp.value));
end
----

The rule unit implements the required `RuleUnitData` interface and declares the data sources for the previously defined types. The sample rule raises an alert when the temperature reaches or exceeds 80 degrees.

=== Data sources for DRL rule units

Data sources are typed sources of data that rule units can subscribe to for updates. You interact with the rule unit through the data sources it exposes.

{PRODUCT} supports the following types of data sources. When you declare data sources in DRL rule files, the sources are internally rendered as shown in these examples.

* `DataStream`: An append-only storage option. Use this storage option when you want to publish or share data values. You can use the notation `DataSource.createStream()` to return a `DataStream<T>` object and use the method `append(T)` to add more data.
+
.Example DataStream data source definition
[source,java]
----
DataStream<Temperature> temperature = DataSource.createStream();
// Append value and notify all subscribers
temperature.append(new Temperature(100));
----

* `DataStore`: A writable storage option for adding or removing data and then notifying all subscribers that mutable data has been modified. Rules can pattern-match against incoming values and update or remove available values.
ifdef::KOGITO-COMM[]
For users familiar with {PRODUCT_DROOLS}, this option is equivalent to a typed version of an entry point. In fact, a `DataStore<Object>` is equivalent to an old-style entry point.
endif::[]
+
.Example DataStore data source definition
[source,java]
----
DataStore<Temperature> temperature = DataSource.createStore();
Temperature temp = new Temperature(100);
// Add value `t` and notify all subscribers
DataHandle t = temperature.add(temp);
temp.setValue(50);
// Notify all subscribers that the value referenced by `t` has changed
temperature.update(t, temp);
// Remove value referenced by `t` and notify all subscribers
temperature.remove(t);
----

* `SingletonStore`: A writable storage option for setting or clearing a single element and then notifying all subscribers that the element has been modified. Rules can pattern-match against the value and update or clear available values.
ifdef::KOGITO-COMM[]
For users familiar with {PRODUCT_DROOLS}, this option is equivalent to a global. In fact, a `Singleton<Object>` is similar to an old-style global, except that when used in conjuction with rules, you can pattern-match against it.
endif::[]
+
.Example SingletonStore data source definition
[source,java]
----
SingletonStore<Temperature> temperature = DataSource.createSingleton();
Temperature temp = new Temperature(100);
// Add value `temp` and notify all subscribers
temperature.set(temp);
temp.setValue(50);
// Notify all subscribers that the value has changed
temperature.update();

Temperature temp2 = new Temperature(200);
// Overwrite contained value with `temp2` and notify all subscribers
temperature.set(temp2);
temp2.setValue(150);
// Notify all subscribers that the value has changed
temperature.update();

// Clear store and notify all subscribers
temperature.clear();
----

Subscribers to a data source are known as _data processors_. A data processor implements the `DataProcessor<T>` interface. This interface contains callbacks to all the events that a subscribed data source can trigger.

.Example DataStream data processor
[source,java]
----
public interface DataProcessor<T> {
    void insert(DataHandle handle, T object);
    void update(DataHandle handle, T object);
    void delete(DataHandle handle);
}
----

The `DataHandle` method is an internal reference to an object of a data source. Each callaback method might or might not be invoked, depending on whether the corresponding data source implements the capability. For example, a `DataStream` source invokes only the `insert` callback, whereas a `SingletonStore` source invokes the `insert` callback on `set` and the `delete` callback on `clear` or before an overwriting `set`.

=== DRL rule unit declaration using Java

As an alternative to declaring fact types and rule units in DRL files, you can also declare types and units using Java classes. In this case, you add the source code to the `src/main/java` folder of your {PRODUCT} project instead of `src/main/resources`.

For example, the following Java classes define the type and rule unit declarations for the example temperature monitoring service:

.Example Temperature class
[source,java]
----
package com.acme;

public class Temperature {
    private final double value;
    public Temperature(double value) { this.value = value; }
    public double getValue() { return value; }
}
----

.Example Alert class
[source,java]
----
package com.acme;

public class Alert {
    private final String severity
    private final String message;
    public Temperature(String severity, String message) {
        this.severity = severity;
        this.message = message;
    }
    public String getSeverity() { return severity; }
    public String getMessage() { return message; }
}
----

.Example rule unit class
[source,java]
----
package com.acme;

import org.kie.kogito.rules.DataSource;
import org.kie.kogito.rules.DataStream;

public class MonitoringService implements RuleUnitData {
    private DataStream<Temperature> temperature = DataSource.createStream();
    private DataStream<Alert> alertData = DataSource.createStream();
    public DataStream<Temperature> getTemperature() { return temperature; }
    public DataStream<Alert> getAlertData() { return alertData; }
}
----

In this scenario, the DRL rule files then stand alone in the `src/main/resources` folder and consist of the `unit` and the rules, with no direct declarations, as shown in the following example:

.Example DRL rule unit file without declarations
[source]
----
package com.acme;
unit MonitoringService;

rule "tooHot"
  when
    $temp : /temperature[value >= 80]
  then
    alertData.append(new Alert("HIGH", "Temperature exceeds threshold: " + temp.value));
end
----

=== DRL rule units with BPMN processes

If you use a DRL rule unit as part of a business rule task in a Business Process Model and Notation (BPMN) process in your {PRODUCT} project, you do not need to create an explicit data type declaration or a rule unit class that implements the `RuleUnitData` interface. Instead, you designate the rule unit in the DRL file as usual and specify the rule unit in the format `unit:__PACKAGE_NAME__.__UNIT_NAME__` in the implementation details for the business rule task in the BPMN process. When you build the project, the business process implicitly declares the rule unit as part of the business rule task to execute the DRL file.

For example, the following is a DRL file with a rule unit designation:

.Example DRL rule unit file
[source]
----
package com.acme;
unit MonitoringService;

rule "tooHot"
  when
    $temp : Temperature( value >= 80 ) from temperature
  then
    alertData.add(new Alert("HIGH", "Temperature exceeds threshold: " + temp.value));
end
----

In the relevant business process in a BPMN 2.0 process modeler, you select the business rule task and for the *Implementation/Execution* property, you set the rule language to `DRL` and the rule flow group to `unit:com.acme.MonitoringService`.

This rule unit syntax specifies that you are using the `com.acme.MonitoringService` rule unit instead of a traditional rule flow group. This is the rule unit that you referenced in the example DRL file. When you build the project, the business process implicitly declares the rule unit as part of the business rule task to execute the DRL file.

[id='con-drl-rules-conditions_{context}']
== Rule conditions in DRL

ifdef::KOGITO-COMM[]
.Rule
image::kogito/drl/rule.png[align="center"]

.Conditional element in a rule
image::kogito/drl/lhs.png[align="center"]
endif::[]

The `when` part of a DRL rule (also known as the _Left Hand Side (LHS)_ of the rule) contains the conditions that must be met to execute an action. Conditions consist of a series of stated OOPath expressions of patterns and constraints, with optional bindings and supported rule condition elements (keywords), based on the available data objects in the package. OOPath is an object-oriented syntax extension to XPath for navigating through related elements while handling collections and filtering constraints.

For example, in a decision service that raises alerts when the temperature reaches or exceeds 80 degrees, a rule `tooHot` contains the `when` condition `/temperature[value >= 80]`.

NOTE: DRL uses `when` instead of `if` because `if` is typically part of a procedural execution flow during which a condition is checked at a specific point in time. In contrast, `when` indicates that the condition evaluation is not limited to a specific evaluation sequence or point in time, but instead occurs continually at any time. Whenever the condition is met, the actions are executed.

If the `when` section is empty, then the conditions are considered to be true and the actions in the `then` section are executed the first time the rules are fired. This is useful if you want to use rules to set up the {DECISION_ENGINE} state.

The following example rule uses empty conditions to insert a fact every time the rule is executed:

.Example rule without conditions
[source]
----
rule "start-up"
  when
    // Empty
  then   // Actions to be executed once
    alerts.add( new Alert("INFO", "System started") );
end
----

Formally, the core grammar of an OOPath expression is defined in extended Backus-Naur form (EBNF) notation in the following way:

.EBNF notation for OOPath expressions
[source]
----
OOPExpr = [ID ( ":" | ":=" )] ( "/" | "?/" ) OOPSegment { ( "/" | "?/" | "." ) OOPSegment } ;
OOPSegment = ID ["#" ID] ["[" ( Number | Constraints ) "]"]
----

=== OOPath expressions and constraints

An _OOPath expression_ of a pattern in a DRL rule condition is the segment to be matched by the {DECISION_ENGINE}. An OOPath expression can potentially match each fact that is inserted into the working memory of the {DECISION_ENGINE}. It can also contain constraints to further define the facts to be matched.

In the simplest form, with no constraints, an OOPath expression matches a fact in the given data source. In the following example with a `DataSource<Person>` named `person`, the expression matches against all `Person` objects in the data source of the {DECISION_ENGINE}:

.Example expression for a single fact type
[source]
----
/person
----

Patterns can also refer to superclasses or even interfaces, potentially matching facts from many different classes. For example, the following pattern matches all `Student` subtypes of the `Person` object:

.Example pattern for subtypes
[source]
----
/person # Student
----

Square brackets in a pattern enclose the constraints, such as the following constraint on the person's age:

.Example pattern with a constraint
[source]
----
/person[ age == 50 ]
----

A _constraint_ is an expression that returns `true` or `false`. Constraints in DRL are essentially Java expressions with some enhancements, such as property access, and some differences, such as `equals()` and `!equals()` semantics for `==` and `!=` (instead of the usual `same` and `not same` semantics).

Any JavaBeans property can be accessed directly from pattern constraints. A JavaBeans property is exposed internally using a standard JavaBeans getter that takes no arguments and returns something. For example, the `age` property is written as `age` in DRL instead of the getter `getAge()`:

.DRL constraint syntax with JavaBeans properties
[source]
----
/person[ age == 50 ]

// This is equivalent to the following getter format:

/person[ getAge() == 50 ]
----

{PRODUCT} uses the standard JDK `Introspector` class to achieve this mapping and follows the standard JavaBeans specification. For optimal {DECISION_ENGINE} performance, use the property access format, such as `age`, instead of using getters explicitly, such as `getAge()`.

[WARNING]
====
Do not use property accessors to change the state of the object in a way that might affect the rules because the {DECISION_ENGINE} caches the results of the match between invocations for higher efficiency.

For example, do not use property accessors in the following ways:

[source,java]
----
public int getAge() {
    age++; // Do not do this.
    return age;
}
----

[source,java]
----
public int getAge() {
    Date now = DateUtil.now(); // Do not do this.
    return DateUtil.differenceInYears(now, birthday);
}
----

Instead of following the second example, insert a fact that wraps the current date in the working memory and update that fact between rule executions as needed.
====

However, if the getter of a property cannot be found, the compiler uses the property name as a fallback method name, without arguments:

.Fallback method if object is not found
[source]
----
/person[ age == 50 ]

// If `Person.getAge()` does not exist, the compiler uses the following syntax:

/person[ age() == 50 ]
----

You can also nest access properties in patterns, as shown in the following example. Nested properties are indexed by the {DECISION_ENGINE}.

// FIXME: revisit this in the future
.Example pattern with nested property access
[source]
----
/person[ address.houseNumber == 50 ]

// This is equivalent to the following expression:

/person[ getAddress().getHouseNumber() == 50 ]
----

// FIXME: revisit this in the future
// WARNING: In stateful KIE sessions, use nested accessors carefully because the working memory of the {DECISION_ENGINE} is not aware of any of the nested values and does not detect when they change. Either consider the nested values immutable while any of their parent references are inserted into the working memory, or, if you want to modify a nested value, mark all of the outer facts as updated. In the previous example, when the `houseNumber` property changes, any `Person` with that `Address` must be marked as updated.

You can use any Java expression that returns a `boolean` value as a constraint inside the parentheses of a pattern. Java expressions can be mixed with other expression enhancements, such as property access:

.Example pattern with a constraint using property access and Java expression
[source]
----
/person[ age == 50 ]
----

You can change the evaluation priority by using parentheses, as in any logical or mathematical expression:

.Example evaluation order of constraints
[source]
----
/person[ age > 100 && ( age % 10 == 0 ) ]
----

You can also reuse Java methods in constraints, as shown in the following example:

.Example constraints with reused Java methods
[source]
----
/person[ Math.round( weight / ( height * height ) ) < 25.0 ]
----

[WARNING]
====
Do not use constraints to change the state of the object in a way that might affect the rules because the {DECISION_ENGINE} caches the results of the match between invocations for higher efficiency. Any method that is executed on a fact in the rule conditions must be a read-only method. Also, the state of a fact should not change between rule invocations unless those facts are marked as updated in the working memory on every change.

For example, do not use a pattern constraint in the following ways:

[source]
----
/person[ incrementAndGetAge() == 10 ] // Do not do this.
----

[source]
----
/person[ System.currentTimeMillis() % 1000 == 0 ] // Do not do this.
----
====

Standard Java operator precedence applies to constraint operators in DRL, and DRL operators follow standard Java semantics except for the `==` and `!=` operators.

The `==` operator uses null-safe `equals()` semantics instead of the usual `same` semantics. For example, the pattern `/person[ firstName == "John" ]` is similar to `java.util.Objects.equals(person.getFirstName(), "John")`, and because `"John"` is not null, the pattern is also similar to `"John".equals(person.getFirstName())`.

The `!=` operator uses null-safe `!equals()` semantics instead of the usual `not same` semantics. For example, the pattern `/person[ firstName != "John" ]` is similar to `!java.util.Objects.equals(person.getFirstName(), "John")`.

If the field and the value of a constraint are of different types, the {DECISION_ENGINE} uses type coercion to resolve the conflict and reduce compilation errors. For instance, if `"ten"` is provided as a string in a numeric evaluator, a compilation error occurs, whereas `"10"` is coerced to a numeric 10. In coercion, the field type always takes precedence over the value type:

.Example constraint with a value that is coerced
[source]
----
/person[ age == "10" ] // "10" is coerced to 10
----

For groups of constraints, you can use a delimiting comma `,` to use implicit `and` connective semantics:

.Example patterns with multiple constraints
[source]
----
// Person is at least 50 years old and weighs at least 80 kilograms:
/person[ age > 50, weight > 80 ]

// Person is at least 50 years old, weighs at least 80 kilograms, and is taller than 2 meters:
/person[ age > 50, weight > 80, height > 2 ]
----

NOTE: Although the `&&` and `,` operators have the same semantics, they are resolved with different priorities. The `&&` operator precedes the `||` operator, and both the `&&` and `||` operators together precede the `,` operator. Use the comma operator at the top-level constraint for optimal {DECISION_ENGINE} performance and human readability.

You cannot embed a comma operator in a composite constraint expression, such as in parentheses:

.Example of misused comma in composite constraint expression
[source]
----
// Do not use the following format:
/person[ ( age > 50, weight > 80 ) || height > 2 ]

// Use the following format instead:
/person[ ( age > 50 && weight > 80 ) || height > 2 ]
----

=== Bound variables in patterns and constraints

You can bind variables to OOPath expressions of patterns and constraints to refer to matched objects in other portions of a rule. Bound variables can help you define rules more efficiently or more consistently with how you annotate facts in your data model.
// evacchi: I think the "new" convention is to drop $ sign
// To differentiate more easily between variables and fields in a rule, use the standard format `$__VARIABLE__` for variables, especially in complex rules. This convention is helpful but not required in DRL.

For example, the following DRL rule uses the variable `$p` for an OOPath expression with the `Person` fact:

.Pattern with a bound variable
[source]
----
rule "simple rule"
  when
    $p : /person
  then
    System.out.println( "Person " + p );
end
----

Similarly, you can also bind variables to nested properties, as shown in the following example:

[source]
----
// Two persons of the same age:
/person[ firstAge : age ]  // Binding
and
/person[ age == firstAge ] // Constraint expression
----

[NOTE]
====
Ensure that you separate constraint bindings and constraint expressions for clearer and more efficient rule definitions. Although mixed bindings and expressions are supported, they can complicate patterns and affect evaluation efficiency.

[source]
----
// Do not use the following format:
/person[ age : age * 2 < 100 ]

// Use the following format instead:
/person[ age * 2 < 100, $age : age ]
----
====


// evacchi: not sure these are supported in OOPath maybe move it in the Pattern section

// The {DECISION_ENGINE} does not support bindings to the same declaration, but does support _unification_ of arguments across several properties. While positional arguments are always processed with unification, the unification symbol `:=` exists for named arguments.

// The following example patterns unify the `age` property across two `Person` facts:

// .Example pattern with unification
// [source]
// ----
// Person( $age := age )
// Person( $age := age )
// ----

// Unification declares a binding for the first occurrence and constrains to the same value of the bound field for sequence occurrences.

=== Nested constraints and inline casts

In some cases, you might need to access multiple properties of a nested object, as shown in the following example:

.Example pattern to access multiple properties
[source]
----
/person[ name == "mark", address.city == "london", address.country == "uk" ]
----

You can group these property accessors to nested objects for more readable rules, as shown in the following example:

.Example pattern with grouped constraints
[source]
----
/person[ name == "mark"]/address[ city == "london", country == "uk" ]
----

When you work with nested objects, you can use the syntax `__TYPE__#__SUB_TYPE__` to cast to a subtype and make the getters from the parent type available to the subtype. You can use either the object name or fully qualified class name, and you can cast to one or multiple subtypes, as shown in the following examples:

.Example patterns with inline casting to a subtype
[source]
----
// Inline casting with subtype name:
/person[ name == "mark"]/address#LongAddress[ country == "uk" ]

// Inline casting with fully qualified class name:
/person[ name == "mark"]/address#org.domain.LongAddress[ country == "uk" ]

// Multiple inline casts:
/person[ name == "mark" ]/address#LongAddress/country#DetailedCountry[ population > 10000000 ]
----

These example patterns cast `Address` to `LongAddress`, and additionally to `DetailedCountry` in the last example, making the parent getters available to the subtypes in each case.

// evacchi: not sure this works with oopath
// You can use the `instanceof` operator to infer the results of the specified type in subsequent uses of that field with the pattern, as shown in the following example:

// [source]
// ----
// Person( name == "mark", address instanceof LongAddress, address.country == "uk" )
// ----

// If an inline cast is not possible (for example, if `instanceof` returns `false`), the evaluation is considered `false`.

=== Date literal in constraints

By default, the {DECISION_ENGINE} supports the date format `dd-mmm-yyyy`. You can customize the date format, including a time format mask if needed, by providing an alternative format mask with the system property `drools.dateformat="dd-mmm-yyyy hh:mm"`. You can also customize the date format by changing the language locale with the `drools.defaultlanguage` and `drools.defaultcountry` system properties. For example, the locale of Thailand is set as `drools.defaultlanguage=th` and `drools.defaultcountry=TH`.

.Example pattern with a date literal restriction
[source]
----
/person[ bornBefore < "27-Oct-2009" ]
----

ifdef::KOGITO-COMM[]
=== Auto-boxing and primitive types

Drools attempts to preserve numbers in their primitive or object wrapper form, so a variable bound to an int primitive when used in a code block or expression will no longer need manual unboxing; unlike early Drools versions where all primitives were autoboxed, requiring manual unboxing.
A variable bound to an object wrapper will remain as an object; the existing JDK 1.5 and JDK 5 rules to handle auto-boxing and unboxing apply in this case.
When evaluating field constraints, the system attempts to coerce one of the values into a comparable format; so a primitive is comparable to an object wrapper.
endif::[]

////
//@comment evacchi: I am not sure the following sections still apply/work. I would hide for now (evacchi, 2020-03-16)*>

== Other Features

OOPath has several other advanced features. We report them here for completeness

* Can backreference an object of the graph that was traversed before the currently iterated graph. For example, the following OOPath expression matches only the grades that are above the average for the passed exam:
+
.Constraints with backreferenced object
[source]
----
grade: /student/plan/exams/grades[ result > ../averageResult ]
----
* Can recursively be another OOPath expression, as shown in the following example:
+
.Recursive constraint expression
[source]
----
exam: /student/plan/exams[ /grades[ result > 20 ] ]
----
* Can access objects by their index between square brackets `[]`, as shown in the following example. To adhere to Java convention, OOPath indexes are 0-based, while XPath indexes are 1-based.
+
.Constraints with access to objects by index
[source]
----
grade: /student/plan/exams[0]/grades
----



== Object reactivity in OOPath expressions

OOPath expressions can be reactive or non-reactive. The {DECISION_ENGINE} does not react to updates involving a deeply nested object that is traversed during the evaluation of an OOPath expression.

To make these objects reactive to changes, modify the objects to extend the class `org.drools.core.phreak.ReactiveObject`. After you modify an object to extend the `ReactiveObject` class, the domain object invokes the inherited method `notifyModification` to notify the {DECISION_ENGINE} when one of the fields has been updated, as shown in the following example:

.Example object method to notify the {DECISION_ENGINE} that an exam has been moved to a different course
[source,java]
----
public void setCourse(String course) {
  this.course = course;
  notifyModification(this);
}
----

With the following corresponding OOPath expression, when an exam is moved to a different course, the rule is re-executed and the list of grades matching the rule is recomputed:

.Example OOPath expression from "Big Data" rule
[source]
----
$grade: /student/plan/exams[ course == "Big Data" ]/grades
----

You can also use the `?/` separator instead of the `/` separator to disable reactivity in only one sub-portion of an OOPath expression, as shown in the following example:

.Example OOPath expression that is partially non-reactive
[source]
----
$grade: /student/plan/exams[ course == "Big Data" ]?/grades
----

With this example, the {DECISION_ENGINE} reacts to a change made to an exam or if an exam is added to the plan, but not if a new grade is added to an existing exam.

If an OOPath portion is non-reactive, all remaining portions of the OOPath expression also become non-reactive. For example, the following OOPath expression is completely non-reactive:

.Example OOPath expression that is completely non-reactive
[source]
----
$grade: /student?/plan/exams[ course == "Big Data" ]/grades )
----

For this reason, you cannot use the `?/` separator more than once in the same OOPath expression. For example, the following expression causes a compilation error:

.Example OOPath expression with duplicate non-reactivity markers
[source]
----
$grade: /student/plan?/exams[ course == "Big Data" ]?/grades
----

Another alternative for enabling OOPath expression reactivity is to use the dedicated implementations for `List` and `Set` interfaces in {PRODUCT}. These implementations are the `ReactiveList` and `ReactiveSet` classes. A `ReactiveCollection` class is also available. The implementations also provide reactive support for performing mutable operations through the `Iterator` and `ListIterator` classes.

The following example class uses these classes to configure OOPath expression reactivity:

.Example Java class to configure OOPath expression reactivity
[source,java]
----
public class School extends AbstractReactiveObject {
  private String name;
  private final List<Child> children = new ReactiveList<Child>(); // <1>

  public void setName(String name) {
      this.name = name;
      notifyModification(); // <2>
  }

  public void addChild(Child child) {
      children.add(child); // <3>
      // No need to call `notifyModification()` here
  }
}
----
<1> Uses the `ReactiveList` instance for reactive support over the standard Java `List` instance.
<2> Uses the required `notifyModification()` method for when a field is changed in reactive support.
<3> The `children` field is a `ReactiveList` instance, so the `notifyModification()` method call is not required. The notification is handled automatically, like all other mutating operations performed over the `children` field.

////

[id='con-drl-rules-actions_{context}']
== Rule actions in DRL

The `then` part of the rule (also known as the _Right Hand Side (RHS)_ of the rule) contains the actions to be performed when the conditional part of the rule has been met. Rule actions are typically determined by one or more _data sources_ that you define as part of your DRL rule unit. For example, if a bank requires loan applicants to have over 21 years of age (with a rule condition `/applicant[ applicantName : name, age < 21 ]`) and a loan applicant is under 21 years old, the `then` action of an `"Underage"` rule would be `setApproved( false )` based on a defined data source, declining the loan because the applicant is under age.

The main purpose of rule actions is to to insert, delete, or modify data in the working memory of the {DECISION_ENGINE}. Effective rule actions are small, declarative, and readable. If you need to use imperative or conditional code in rule actions, then divide the rule into multiple smaller and more declarative rules.

.Example rule for loan application age limit
[source]
----
rule "Underage"
  when
    /applicant[ applicantName : name, age < 21 ]
    $application : /loanApplication[ applicant == applicantName ]
  then
    $application.setApproved( false );
    $application.setExplanation( "Underage" );
end
----

For more information about using data sources for rule actions, see xref:con-drl-rule-units_drl-rules[].

include::{asciidoc-dir}/decision-engine/chap-kogito-decision-engine.adoc[tags=con-property-change-listeners]

[id='proc-drl-rules-central-create_{context}']
== Creating DRL rules for your {PRODUCT} project

You can create and manage DRL rules for your {PRODUCT} project in your integrated development environment (IDE). For {PRODUCT} service, VSCode is the preferred IDE. In each DRL rule file, you define rule conditions, actions, and other components related to the rule, based on the data objects you create or import in the package.

In {PRODUCT}, you typically define DRL rules in rule units. A DRL rule unit is a module for rules and a unit of execution. A rule unit collects a set of rules with the declaration of the type of facts that the rules act on. A rule unit also serves as a unique namespace for each group of rules. A single rule base can contain multiple rule units. You typically store all the rules for a unit in the same file as the unit declaration so that the unit is self-contained.

For this procedure, create the following example DRL type declarations and DRL rule unit to define DRL rules in a decision service for a loan application:

.Example DRL type declarations for a loan application
[source]
----
package org.mortgages;

declare Bankruptcy
    name: String
    yearOfOccurrence: int
end

declare Applicant
    name: String
    age: int
end

declare LoanApplication
    applicant: String
    approved: boolean
    explanation: String
end
----

.Example DRL rule unit file for a loan application
[source]
----
package org.mortgages;
unit MortgageRules;

import org.kie.kogito.rules.DataSource;
import org.kie.kogito.rules.DataStream;

declare MortgageRules extends RuleUnitData
  bankruptcy: DataStore<Bankruptcy> = DataSource.createStore()
  applicant: DataStore<Applicant> = DataSource.createStore()
  application: DataStore<LoanApplication> = DataSource.createStore()
end

rule "Bankruptcy history"
	salience 10
	when
    $a : /loanApplication[ applicantName: applicant ]
    exists (/bankruptcy[ name == applicantName, yearOfOccurrence > 1990 || amountOwed > 100000 ])
	then
		$a.setApproved( false );
		$a.setExplanation( "has been bankrupt" );
		loanApplication.remove( $a );
end

rule "Underage"
	salience 15
	when
    /applicant[ applicantName : name, age < 21 ]
    $application : /loanApplication[ applicant == applicantName ]
	then
		$application.setApproved( false );
		$application.setExplanation( "Underage" );
		loanApplication.remove( $a );
end
----

.Prerequisites
* You have created a {PRODUCT} project and have included any Java data objects required for your {PRODUCT} service. For information about creating a project, see
ifdef::KOGITO-ENT[]
{URL_CREATING_RUNNING}[_{CREATING_RUNNING}_].
endif::[]
ifdef::KOGITO-COMM[]
xref:chap-kogito-creating-running[].
endif::[]

.Procedure
. In your VSCode IDE, open your {PRODUCT} project and create a `src/main/resources/org/mortgages` folder. This folder serves as the package for your DRL files in this example.
. In your new `src/main/resources/org/mortgages` folder, add the following `ApplicationTypes.drl` file to define the fact types for the loan application service:
+
--
.Example DRL type declarations for a loan application
[source]
----
package org.mortgages;

declare Bankruptcy
    name: String
    yearOfOccurrence: int
end

declare Applicant
    name: String
    age: int
end

declare LoanApplication
    applicant: String
    approved: boolean
    explanation: String
end
----

This DRL file defines the fact types that you can declare in any rule units in the same package for the decision service. Declarations in DRL files define new fact types or metadata for fact types to be used by rules in a DRL files. If you declare these types directly in the DRL rule unit file, you cannot declare them in any other rule units.

This example defines the following fact types:

* `Bankruptcy`: Provides data for bankruptcy status, if applicable
* `Applicant`: Provides data about the loan applicant
* `LoanApplication`: Provides data about loan approval status for a specified applicant, with an explanation if needed
--
. In the same `src/main/resources/org/mortgages` folder of your {PRODUCT} project, create the following `LoanApplication.drl` file to declare the DRL rule unit and data sources:
+
--
.Example DRL file with rule unit and data sources
[source]
----
package org.mortgages;
unit MortgageRules;

import org.kie.kogito.rules.DataSource;
import org.kie.kogito.rules.DataStore;

declare MortgageRules extends RuleUnitData
  bankruptcy: DataStore<Bankruptcy> = DataSource.createStore()
  applicant: DataStore<Applicant> = DataSource.createStore()
  application: DataStore<LoanApplication> = DataSource.createStore()
end
...
----

In this example, the rule unit is named `MortgageRules` and the previously defined fact types are declared as `DataStore` data sources.

Data sources are typed sources of data that rule units can subscribe to for updates. You interact with the rule unit through the data sources it exposes. A data source can be a `DataStream` source for append-only storage, a `DataStore` source for writable storage to add or remove data, or a `SingletonStore` source for writable storage to set and clear a single element.

This example uses the `DataStore` data source to enable application data to be added or removed as part of the decision service.
--
. To complete the DRL rule unit file, add the following rules for `"Bankruptcy history"` and `"Underage"` logic:
+
--
.Example DRL rule unit file for a loan application
[source]
----
package org.mortgages;
unit MortgageRules;

import org.kie.kogito.rules.DataSource;
import org.kie.kogito.rules.DataStream;

declare MortgageRules extends RuleUnitData
  bankruptcy: DataStore<Bankruptcy> = DataSource.createStore()
  applicant: DataStore<Applicant> = DataSource.createStore()
  application: DataStore<LoanApplication> = DataSource.createStore()
end

rule "Bankruptcy history"
	salience 10
	when
    $a : /loanApplication[ applicantName: applicant ]
    exists (/bankruptcy[ name == applicantName, yearOfOccurrence > 1990 || amountOwed > 100000 ])
	then
		$a.setApproved( false );
		$a.setExplanation( "has been bankrupt" );
		loanApplication.remove( $a );
end

rule "Underage"
	salience 15
	when
    /applicant[ applicantName : name, age < 21 ]
    $application : /loanApplication[ applicant == applicantName ]
	then
		$application.setApproved( false );
		$application.setExplanation( "Underage" );
		loanApplication.remove( $a );
end
----

The example rules consist of the following rule components:

* `rule`: Use this segment to define each rule in the DRL file. Rules consist of a rule name in the format `rule "rule name"`, followed by optional attributes that define rule behavior, such as `salience` or `no-loop`, followed by `when` and `then` definitions. Each rule must have a unique name within the rule package.
+
In this example, the `"Bankruptcy history"` rule has a defined salience of `10` and the `"Underage"` rule has a defined salience of `15`. These values ensure that the `"Bankruptcy history"` rule is executed first.
* `when` and `then`: Use the `when` portion to define the condition patterns and constraints in OOPath syntax and use the `then` portion to define the actions to be executed when the conditions are met.
+
In this example, the `"Bankruptcy history"` rule states that if an applicant has owed more than 100,000 USD of unresolved debt since 1990 (beginning 1991), then the applicant is considered to have been bankrupt and is not approved for a loan. The application is removed from memory.
+
If the applicant passes the bankruptcy check, then the `"Underage"` rule states that if the applicant is younger than 21 years old, then the applicant is not approved for the loan. The application is removed from memory.
+
If the applicant passes both checks, then the loan is approved.
--
. After you define all components of the data sources and rules, save all DRL files.

.Additional resources
* xref:con-drl-rule-units_drl-rules[]
* xref:con-drl-rules-conditions_drl-rules[]
* xref:con-drl-rules-actions_drl-rules[]

include::chap-kogito-using-dmn-models.adoc[tags=con-kogito-service-execution]
